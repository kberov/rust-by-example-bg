# Заемане

През повечето време искаме достъп до данните без да ги овладяваме. За да
постигне това Ръждьо ползва *заемане*. Вместо да подаваме обекти като стойности
(`T`), можем да подаваме обекти като препратки (`&T`).

Компилаторът прави статична проверка и гарантира (чрез проверка на заеманията),
че препратките *винаги* сочат към действителни обекти. Сиреч, ако към някой обект
има препратки, обектът не може да бъде унищожен.

```rust,editable,ignore,mdbook-runnable
// Тази функция овладява една кутия и я унищожава
fn ям_кутия_i32(boxed_i32: Box<i32>) {
    println!("Унищожавам кутия, съдържаща {}", boxed_i32);
}

// Тази функция заема стойност от тип i32
fn заемам_кутия_i32(borrowed_i32: &i32) {
    println!("Това цяло число е: {}", borrowed_i32);
}

fn main() {
    // Създаваме променливи – i32 в кутия, съхранвяано на купа̀, и i32 в стека
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // Заемаме съдържанието на кутията. Владението не е прехвърлено, така че
    // съдържанията могат да бъдат заети отново.
    заемам_кутия_i32(&boxed_i32);
    заемам_кутия_i32(&stacked_i32);

    {
        // Вземаме препратка към данните, от кутията
        let _ref_to_i32: &i32 = &boxed_i32;

        // Грешка!
        // Невъзможно е да бъде унищожена `boxed_i32`, докато вътрешната ѝ
        // стойност е заета по-късно и е в обхват.
        ям_кутия_i32(boxed_i32);
        // ПОПРАВИ ^ Коментирайте този ред

        // Опит за заемане на `_ref_to_i32` след като вътрешната стойност е
        // унищожена
        заемам_кутия_i32(_ref_to_i32);
        // `_ref_to_i32` излиза от обхват и вече не е заета.
    }

    // `boxed_i32` сега може да предаде владението на `ям_кутия_i32` и да бъде
    // унищожена
    ям_кутия_i32(boxed_i32);
}
```
