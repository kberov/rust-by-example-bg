# Разнородни списъци

Разнородният списък е набор от стойности с различни типове. Разнородните
списъци се създават с помощта на кръгли скоби `()` и всеки списък е стойност с
описание на типа `(T1, T2, ...)`, където `T1`, `T2`  са типовете на неговите
членове. Функциите могат да използват такива списъци, за да връщат множество
стойности, тъй като разнородните списъци могат да съдържат всякакъв брой
стойности.

```rust,editable

// Разнородните могат да бъдат ползвани като аргументи и като стойност за връщане.
fn reverse(pair: (i32, bool)) -> (bool, i32) {
    //  С помощта на `let` можем да присвоим отделните членове на променливи.
    let (int_param, bool_param) = pair;

    (bool_param, int_param)
}

// Следната структура е за упражнението.
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // Списък с повече разнородни стойности.
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // Стойностите се извличат чрез указване на поредния номер (индексиране).
    println!("Long tuple first value: {}", long_tuple.0);
    println!("Long tuple second value: {}", long_tuple.1);

    // Разнородни могат да бъдат членове на други разнородни.
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // Разнородните са печатаеми.
    println!("tuple of tuples: {:?}", tuple_of_tuples);

    // Но дълги разнородни (по-големи от 12 члена) не са печатаеми.
    //let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    //println!("Too long tuple: {:?}", too_long_tuple);
    // ЗАДАЧА ^ Разкоментирайте горните два реда,
    // за да видите грешката при компилация.

    let pair = (1, true);
    println!("Чифтът е {:?}", pair);

    println!("Обърнатият чифт е {:?}", reverse(pair));

    // За да създадете разнороден списък с единична буквална стойност, трябва
    // да поставите запетая след единствената стойност и да оградите цялото с
    // кръгли скоби. Така компилаторът може да я отличи от обикновена буквална
    // стойност, оградена със скоби.
    println!("Едночленен разнороден списък: {:?}", (5u32,));
    println!("Просто едно цяло число: {:?}", (5u32));

    // Разнородните списъци могат да бъдат разлагани на отделни променливи.
    let tuple = (1, "hello", 4.5, true);
    let (a, b, c, d) = tuple;
    println!("{:?}, {:?}, {:?}, {:?}", a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!("{:?}", matrix);
}
```

### Упражнения

1. *Преговор*: Добавете `fmt::Display` към структурата `Matrix` в примера горе,
   така че, ако използвате формата `{}`, да видите следния изход:

   ```text
   ( 1.1 1.2 )
   ( 2.1 2.2 )
   ```

   За да си припомните, може да се върнете на примера с [отпечатване чрез
   `fmt::Display`][print_display].
2. Добавете функция `transpose`[^transpose], която приема `matrix` като
   аргумент и връща матрица, на която средните два елемента са разместени.
   Използвайте `reverse` за образец[^template].  Пример:

   ```rust,ignore
   println!("Matrix:\n{}", matrix);
   println!("Transpose:\n{}", transpose(matrix));
   ```

   Изход:

   ```text
   Matrix:
   ( 1.1 1.2 )
   ( 2.1 2.2 )
   Transpose:
   ( 1.1 2.1 )
   ( 1.2 2.2 )
   ```

## Б.пр.
[^transpose]: transpose – размествам, премествам от другата страна,
 сменям местата на две неща

[^template]: образец (шаблон) – template

[print_display]: ../hello/print/print_display.md
