# Списъци и отрязъци

Списъкът[^array] е сбирка от обекти[^objects] с един и същи тип `T`,
съхранявани в съседни клетки от паметта. Списъците се създават с помощта на
квадратни скоби `[]`. Дължината им се знае още по време на компилиране и е част
от описанието на типа `[T; дължина]`.

Отрязъците[^slices] са подобни на списъците, но тяхната дължина е неизвестна
по време на компилация. Отрязъкът е двусловен обект – първата дума е указател
към данните, а втората показва размера (дължината) на отрязъка. Типа на размера
е същия като `usize`, сиреч 64 бита при архитектура x86-64. Отрязъците могат да
бъдат използвани за заемане[^borrow] на дял (отрязък) от списък и имат
описание[^signature] на типа `&[T]`.

```rust,editable,ignore,mdbook-runnable
use std::mem;

// Тази функция заема (взема на заем) резен от списък.
fn analyze_slice(slice: &[i32]) {
    println!("Първи член на отрязъка: {}", slice[0]);
    println!("Отрязъкът има {} члена", slice.len());
}

fn main() {
    // Списък с непроменим размер (описанието на типа ([i32; 5]) е излишно).
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    //  Всички членове може да се зададат предварително с определена еднаква за
    // всички стойност.
    let ys: [i32; 500] = [0; 500];

    // Броенето (индексирането) започва от 0.
    println!("Първи член на списъка: {}", xs[0]);
    println!("Втори член на списъка: {}", xs[1]);

    // `len` връща броя на членовете в списъка.
    println!("Брой на членовете в списъка: {}", xs.len());

    // Списъците се слагат на кама̀рата.
    println!("Списъкът заема {} байта", mem::size_of_val(&xs));

    // Списъците могат да бъдат заемани автоматично, като отрязъците.
    println!("Заемаме целия списък като отрязък.");
    analyze_slice(&xs);

    // Отрязъците могат да сочат към дял(част) от списък.
    // Те изглеждат така: [начално_място..крайно_място].
    // `начално_място` е мястото в списъка, което ще бъде първо в отрязъка.
    // `крайно_място` е с едно по-голямо от последното място в резена.
    println!("Заемаме дял от списъка като отрязък.");
    analyze_slice(&ys[1 .. 4]);

    // Пример за празен отрязък: `&[]`:
    let празна_поредица: [u32; 0] = [];
    assert_eq!(&празна_поредица, &[]);
    assert_eq!(&празна_поредица, &[][..]); // Същото, но по-подробно

    // Членовете на списъците могат да бъдат достъпвани безопасно като
    // използваме метода `.get`, който връща `Option`. Това може да се ползва при
    // намиране на съвпадения или да се ползва с `.expect()`, ако искате
    // програмата ви да излиза с хубаво съобщение вместо просто да продължава.
    for i in 0..xs.len() + 1 { // Опаа с един член повече!
        match xs.get(i) {
            Some(xval) => println!("{}: {}", i, xval),
            None => println!("По-полека, забави, забави! {} е в повече!", i),
        }
    }

    // Достъп до член извън границите на списък причинява грешка по време
    // на компилация.
    //println!("{}", xs[5]);
    // Достъп до член извън границите на отрязък причинява грешка по време
    // на изпълнение.
    //println!("{}", xs[..][5]);
}
```
## Бележки на преводача

Бележките по-долу описват избраните български думи. Ще се стремим да ги
ползваме с предимство. Целта е да поизчистим езика ни от заливащите ни
американизми. В края на османското владичество езикът ни е приличал на езика на
програмистите и по-младите днес, само че с турски думи. По това явление можем
да съдим под чие владичество се намираме.

[^array]: списък, поредица, масив - array

[^objects]:  предмети, обекти  – objects

[^slices]: отрязъци, рѐзени – slices

[^borrow]: заемане, заемка заемам, вземам на заем – borrowwing, borrow

[^signature]: описание, обявление – signature
