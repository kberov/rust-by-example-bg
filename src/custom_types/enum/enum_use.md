# use

С обявлението `use` (*ползвам*) избягваме ръчното задаване на пълния път за текущия обхват[^scoping]:

```rust,editable
// Скриваме предупрежденията за неизползван код.
#![allow(dead_code)]

enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}

fn main() {
    // Изрично `use` (указваме, че ще ползваме) всяко име.
    // Така избягваме изписването на пълния път до него.
    use crate::Status::{Poor, Rich};
    // Автоматично `use` (използваме) всяко име от `Work`.
    use crate::Work::*;

    // Същото като `Status::Poor`.
    let status = Poor;
    // Същото като `Work::Civilian`.
    let work = Civilian;

    match status {
        // Забележете, че вариантите са видими без указване на обхвата,
        // понеже изрично ползвахме `use` горе.
        Rich => println!("Богатият има много пари"),
        Poor => println!("Бедният няма пари..."),
    }

    match work {
        // Отново не указваме обхвата (пълния път до вариантите).
        Civilian => println!("Цивилните работят!"),
        Soldier  => println!("Войниците се бият!"),
    }
}
```

## Б.пр.

[^scoping]: указване на обхвата („взор” от гр.) на променливите – scoping;
  обхват (взор), между кои две фигурни скоби (блок от код) е видима
  променливата (в какъв обхват) – scope. Това е различно от _видимост_ –
  visibility, където се има предвид общодостъпност (`pub`) и частност на
  единиците (променливи, типове, функции).

### Вижте също:

[`match`][match] и [`use`][use] 

[use]: ../../mod/use.md
[match]: ../../flow_control/match.md
