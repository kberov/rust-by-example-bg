# Привеждане към тип

Ръждьо не прави неявно (принудително) привеждане[^coercion] между първичните типове. Но
изрично привеждане[^casting] може да се прави с помощта на ключовата дума `as` (като).

Правилата за преобразуване между целочислените стойности следват тези в езика C като
цяло, освен в случаите, където в C поведенеието е неопределено. Поведението при
преобразуване между всички целочислени типове е строго определено в Ръждьо.

```rust,editable,ignore,mdbook-runnable
// Подтискаме всички предупреждения за преливащи привеждания между типовете.
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // Грешка! Няма неявно привеждане (coercion)
    let integer: u8 = decimal;
    // ПОПРАВИ ^ Да се коментира този ред

    // Изрично привеждане (casting)
    let integer = decimal as u8;
    let character = integer as char;

    // Грешка! Има някои ограничения при привеждане.
    // Десетична дроб не може да се приведе
    // направо към писмен знак `char`.
    let character = decimal as char;
    // ПОПРАВИ ^ Да се коментира този ред

    println!("Привеждане: {} -> {} -> {}", decimal, integer, character);

    // Когато се привежда каквато и да е стойност към беззнаков тип, T,
    // T::MAX + 1 се добавя или изважда,
    // докато стойността не се побере в новия тип.

    // 1000 се побира в u16
    println!("1000 като u16 е: {}", 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // Подробности: първите 8 най-малко значими (младши) битове (LSB) се
    // запазват, а старшите (MSB) се орязват.
    println!("1000 като u8 е : {}", 1000 as u8);
    // -1 + 256 = 255
    println!("  -1 като u8 е : {}", (-1i8) as u8);

    // За положителни числа това е същото като получаване на остатък
    println!("Остатꙑкът от 1000, делено на 256, е: {}", 1000 % 256);

    // Когато привеждаме към знаков тип, побитовият резултат е същият като
    // първото привеждане към съответстващия беззнаков тип. Ако най-значимият
    // бит на стойността е 1, то стойността е отрицателна.

    // Освен, разбира се, когато стойността се побира в типа.
    println!(" 128 като i16 е: {}", 128 as i16);

    // В граничния случай стойността на 128, 
    // представена в 8-бита с допълнение до две, е -128
    println!(" 128 as a i8 is : {}", 128 as i8);

    // повтаряме примера от горе
    // 1000 като u8 -> 232
    println!("1000 като u8 е : {}", 1000 as u8);
    // и стойността на 232, 
    //представена в 8-бита с допълнение до две, е -24
    println!(" 232 as a i8 is : {}", 232 as i8);

    // От Ръждьо 1.45, ключовата дума `as` работи като *наситено привеждане*,
    // когато привеждаме от тип с плаваща запетая към целочислен тип. Ако
    // дробната стойност надвишава горната граница или е по-малка от долната
    // граница, върнатата стойност ще бъде равна на прескочената граница.

    // 300.0 като u8 е 255
    println!(" 300.0 като u8 е: {}", 300.0_f32 as u8);
    // -100.0 като u8 е 0
    println!("-100.0 като u8 е: {}", -100.0_f32 as u8);
    // NAN като u8 е 0
     println!(" NAN     като u8 е: {}", f32::NAN as u8);

    // Това поведение разходва малко от времето на изпълнение и може да бъде
    // избегнато чрез опасни методи. Обаче резултатът може да прелее и да върне
    // **ненадеждни стойности**. Използвайте тези методи разумно.
    unsafe {
        // 300.0 като u8 е 44
        println!(" 300.0 като u8 е : {}", 300.0_f32.to_int_unchecked::<u8>());
        // -100.0 като u8 е 156
        println!("-100.0 като u8 е : {}", (-100.0_f32).to_int_unchecked::<u8>());
        //  NAN като u8 е 0
        println!("   NAN като u8 е : {}", f32::NAN.to_int_unchecked::<u8>());
    }
}
```

---
## Бележки на преводача

*Привеждането (casting)* (на един тип към друг) е различно от *превръщането
(conversion)*. За привеждане се ползва ключовата дума `as`. Извършва се просто
*вместване* на стойността в друг тип. Когато целевият числов тип е по-малък,
при това действие стойността може да „прелее” и да загубим данни.

*Превръщането (conversion)* се прави при съставни и потребителски типове и се
осъществява чрез [отличители][traits]. Разглежда се в следващата глава –
[Превръщане][conversion].


преливащи привеждания между типовете – casts which overflow

[^coercion]: мълчаливо привеждане насила (от един тип към друг) – coercion 

[^casting]: изрично привеждане (към друг тип) – casting

[traits]: ../../trait.md
[conversion]: ../../conversion.md
