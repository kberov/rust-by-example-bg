# Заемане

През повечето време искаме достъп до данните, без да ги овладяваме. За да
постигне това, Ръждьо ползва *заемане*. Вместо да подаваме обекти като стойности
(`T`), можем да подаваме обекти като препратки (`&T`).

Компилаторът прави статична проверка и гарантира (чрез своя проверител на заемките),
че препратките *винаги* сочат към действителни обекти. Сиреч, ако към някой обект
има препратки, обектът не може да бъде унищожен.

```rust,editable,ignore,mdbook-runnable
// Тази функция овладява една кутия и я унищожава
fn ям_кутия_i32(boxed_i32: Box<i32>) {
    println!("Унищожавам кутия, съдържаща {}", boxed_i32);
}

// Тази функция заема стойност от тип i32
fn заемам_i32(borrowed_i32: &i32) {
    println!("Това цяло число е: {}", borrowed_i32);
}

fn main() {
    // Създаваме променливи – i32 в кутия (съхранявана на купа̀) и i32 на стълп
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // Заемаме съдържанието на кутията. Владението не е прехвърлено, така че
    // съдържанието може да бъде заемано отново.
    заемам_кутия_i32(&boxed_i32);
    заемам_от_стълп_i32(&stacked_i32);

    {
        // Вземаме препратка към данните, съдържащи се в кутията
        let _ref_to_i32: &i32 = &boxed_i32;

        // Грешка!
        // Невъзможно е да бъде унищожена `boxed_i32`, докато вътрешната ѝ
        // стойност е заета по-късно в обхвата.
        ям_кутия_i32(boxed_i32);
        // ПОПРАВИ ^ Коментирайте този ред

        // Опит за заемане на `_ref_to_i32`, след като вътрешната стойност е
        // унищожена
        заемам_i32(_ref_to_i32);
        // `_ref_to_i32` излиза от обхват и вече не се заема.
    }

    // `boxed_i32` вече може да предаде владението на `ям_кутия_i32` и да бъде
    // унищожена
    ям_кутия_i32(boxed_i32);
}
```
