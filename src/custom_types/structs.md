# Структури

Има три вида структури (structs), които могат да бъдат създавани с ключовата
дума `struct`:

* Списъчни структури, които са просто именувани разнородни списъци;
* Класически – [съшите като в C][c_struct];
* Единични (Unit) структури, които нямат полета и са полезни за обобщения.

```rust,editable
// Атрибут за скриване на предупрежденията за неизползван код.
#![allow(dead_code)]
// Спираме предупрежденията за необичайни знаци.
#![allow(uncommon_codepoints)]

#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// Единична структура
struct Unit;

// Списъчна структура
struct Pair(i32, f32);

// Структура с две полета
struct Point {
    x: f32,
    y: f32,
}

// Структурите могат да бъдат преизползвани като полета в други структури.
struct Четирѭгълник {
    // Четирѭгълникът може да се опише като се укаже къде се намират горния ляв
    // и долния десен ъгъл в пространството.
    горе_ляво: Point,
    долу_дясно: Point,
}

fn main() {
    // Могат да се създават структури, като за стойности на полетата се подадат
    // променливи със същите имена.
    let name = String::from("Peter");
    let age = 27;
    let peter = Person { name, age };

    // отпечатваме структурата 
    println!("{:?}", peter);

    // Създаваме нова структура с тип `Point`
    let point: Point = Point { x: 10.3, y: 0.4 };

    // Достъпваме полетата на point
    println!("Координати на точката: ({}, {})", point.x, point.y);

    // Създаваме нова "точка", като използваме правописа за обновяване чрез
    // използване на полетата на старата.
    let долу_дясно = Point { x: 5.2, ..point };

    // `долу_дясно.y` ще има същата стойност като `point.y` защото
    // използвахме това поле от `point`
    println!("Втора точка: ({}, {})", долу_дясно.x, долу_дясно.y);

    // Разлагаме точката в променливи left_edge и top_edge, като използваме
    // *обвързване* чрез `let`
    let Point { x: left_edge, y: top_edge } = point;

    let _rectangle = Четирѭгълник {
        // създаването на структура също е израз (връща стойност)
        горе_ляво: Point { x: left_edge, y: top_edge },
        // ползваме променлива с името на полето, за да му дадем стойност
        долу_дясно,
    };

    // Създаваме инстанция (нов предмет) на единичната структура Unit.
    let _unit = Unit;

    // Инстанциираме нов Pair - списъчна структура
    let pair = Pair(1, 0.1);

    // Достъп до стойностите на полетата на предмета на списъчната структура
    println!("pair contains {:?} and {:?}", pair.0, pair.1);

    // Разлагаме чрез списъчна структура
    let Pair(integer, decimal) = pair;

    println!("pair contains {:?} and {:?}", integer, decimal);
}
```

## Бележки на преводача

Обвързването (`binding`) в Рѫждьо е същото като присвояване на стойност на променлива в
другите езици. Тук `обвързваме` дадена стойност с име.

Виждаме, че можем да ползваме азбука дори в имената на структурите и функциите,
не само на променливите.

### Упражнения

1. Добавете функция `rect_area`, която изчислява площта на един `Четирѭгълник`
   ( опитайте да ползвате вложено разлагане).
2. Добавете функция `square`, която приема променлива от тип `Point` и
   променлива от тип `f32` като аргументи, и връща тип `Четирѭгълник`, чиито
   горен ляв ъгъл е същият кто точката, а ширината и дължината съответстват на
   подадената променлива от тип `f32`.

### Вижте също

[`attributes`][attributes], and [destructuring][destructuring]

[attributes]: ../attribute.md
[c_struct]: https://en.wikipedia.org/wiki/Struct_(C_programming_language)
[destructuring]: ../flow_control/match/destructuring.md
