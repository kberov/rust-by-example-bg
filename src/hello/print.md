# Форматиране

Отпечатването на текст в конзолата се управлява от набор [`макроси`][macros], описани в пакета [`std::fmt`][fmt].
Някои от тях са:

* `format!`: пише форматиран текст в [`String`][string]
* `print!`: също като `format!`, но текстът бива изведен на конзолата
  (io::stdout).
* `println!`: като `print!`, но накрая се добавя и нов ред.
* `eprint!`: също като `print!`, но текстът се отпечатва в стандартния поток за
грешки  (io::stderr).
* `eprintln!`: също като `eprint!` но накрая се добавя и нов ред. 

Всички макроси обработват текста по един и същи начин. Освен това Ръждьо
проверява правилността на форматирането по време на компилиране. 

```rust,editable,ignore,mdbook-runnable
fn main() {
    // Означенията `{}` ще бъдат автоматично заменени с каквито и да са подадени
    // аргументи. А самите аргументи ще бъдат превърнати в низове.
    println!("{} days", 31);

    // Може да се използват местата на аргументите. Указвайки число между
    // `{}`, определяте кой по ред аргумент да бъде сложен там
    // Броенето на аргументите започва от 0 непосредствено след 
    // форматирания низ.
    println!("{0}, това е {1}. {1}, това е {0}", "Alice", "Bob");

    // Както и именувани аргументи.
    println!("{subject} {verb} {object}",
             object="мързеливото куче",
             subject="бързата кафява котка",
             verb="скача върху");

    // Може да се приложи различно форматиране чрез знак за формат
    // след двуеточие `:`.
    println!("Основа 10:                   {}",   69420); // 69420
    println!("Основа  2 (двоично):         {:b}", 69420); // 10000111100101100
    println!("Основа  8 (осмично):         {:o}", 69420); // 207454
    println!("Основа 16 (шестнадесетично): {:x}", 69420); // 10f2c
    println!("Основа 16 (шестнадесетично): {:X}", 69420); // 10F2C

    // Можете да равнявате текст надясно като укажете ширината. Следното ще
    // изведе "    1". (Четири празноти и "1" с обща ширина 5.)
    println!("{число:>5}", число=1);

    // Можете да указвате отстъпи с нули,
    println!("{number:0>5}", number=1); // 00001
    // и да подравнявате вляво като обърнете знака. Следното ще изведе "10000".
    println!("{number:0<5}", number=1); // 10000

    // Можете да използвате именувани аргументи за формат
    // като долепите знака $ отзад.
    println!("{number:0>width$}", number=1, width=5);   

    // Ръждьо дори проверява дали са подадени нужния брой аргументи.
    println!("Казвам се {0}, {1} {0}", "Бонд");
    // ПОПРАВИ ^ Добавете липсващия аргумент: "Джеймс"

    // Само типове, осъществяващи fmt::Display могат да бъдат форматирани с `{}`.
    // Потребителските типове не осъществятват fmt::Display по подразбиране.

    #[allow(dead_code)] // изключва предупрежденията за `dead_code` (мъртъв код)
    // Нещо обявено и неизползвано по-късно.
    struct Structure(i32);

    // Следното няма да се компилира, защото `Structure` не осъществява
    // fmt::Display.
    // println!("Тази структура `{}` няма да се отпечати…", Structure(3));
    // ЗАДАЧА ^ Разкоментирайте горния ред.

    // От Ръждьо 1.58 нагоре можете да ползвате вече обявена променлива
    // Както и по-горе следното ще произведе
    // "    1", 4 празноти и "1",
    let число: f64 = 1.0; // и името на променливата може да е с български букви!
    let width: usize = 5;
    println!("{число:>width$}");
}
```

Пакетът [`std::fmt`][fmt] съдържа много [отличители (`traits`)][отличители],
управляващи показването на текст. Ето два от важните.

* `fmt::Debug`: Използва обозначението `{:?}`. Форматира текст с цел разбор на грешки.
* `fmt::Display`: Използва обозначението `{}`.  Форматира текст по-разбираемо за потребителя.

Тук използвахме `fmt::Display`, понеже стандартната библиотека (std) 
осъществява тези типове. За да представите като текст потребителски типове, са нужни повече стъпки.

Като осъществите отличителя `fmt::Display` автоматично осъществявате отличителя
[`ToString`], който ни позволява да [превърнем] типа в  [низ (`String`)][string].

`#[allow(dead_code)]` на *ред 47*,  е [атрибут], който важи само за модула след него.

### Упражнения

* Поправете кода по-горе (вижте ЗАПОПРАВКА), така че да работи без грешка.
* Разкоментирайте реда, където се опитваме да форматираме структурата `Structure`
  (вижте ЗАДАЧА).
* Добавете извикване на макроса `println!`, който да изписва: `Числото Пи е
  3.142` като определите видимия брой знаци след десетичната запетая. За целта
  на това упражнение използвайте `let pi = 3.141592` като приближение за Пи.
  (Съвет: Потърсете в документацията на [`std::fmt`][fmt] как се настройва
  показвания брой цифри след десетичната запетая).

## Б.пр.

означение – marker

### Вижте също:

[`std::fmt`][fmt], [`macros`][macros], [`struct`][structs], [`traits`][traits], and [`dead_code`][dead_code]

[fmt]: https://doc.rust-lang.org/std/fmt/
[macros]: ../macros.md
[string]: ../std/str.md
[structs]: ../custom_types/structs.md
[отличители]: https://doc.rust-lang.org/std/fmt/#formatting-traits
[traits]: https://doc.rust-lang.org/std/fmt/#formatting-traits
[`ToString`]: https://doc.rust-lang.org/std/string/trait.ToString.html
[превърнем]: ../conversion/string.md
[атрибут]: ../attribute.md
[dead_code]: ../attribute/unused.md
