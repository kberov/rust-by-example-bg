# Превъртане чрез `for` 

## for и range

Действието `for in` може да се използва за повторение чрез [`Iterator`][iter]
(*повторител*[^iterator]). Един от най-лесните начини да се създаде повторител е като се
използва означението за *редица*[^range] `a..b`. Така произвеждаме стойности от `a`
(включително) до `b`(без `b`), където стъпката е една стойност.

Да напишем FizzBuzz като използваме `for` вместо `while`.

```rust,editable
fn main() {
    // `n` ще приеме стойност: 1, 2, ..., 100 при всяко повторение
    for n in 1..101 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }
    }
}
```

Ако искаме редицата да включва и първата, и последната стойност, трябва да
ползваме означението `a..=b`. Горното може да бъде написано така:

```rust,editable
fn main() {
    // `n` ще приеме стойност: 1, 2, ..., 101 при всяко повторение
    for n in 1..=101 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }
    }
}
```

## for и повторителите

Действието `for in` може да си взаимодейства с даден `Iterator` по няколко
начина. Както се разисква в раздела за отличителя [Iterator][iter], цикълът
`for` ще приложи метода `into_iter` върху *сбирка*[^collection] от неща, които има за
обхождане. Това обаче не е единственият начин за превръщане на сбирки в
повторители.

Методите `into_iter`, `iter` и `iter_mut` превръщат някаква сбирка от неща в
повторител по различни начини, като предоставят различен поглед (и възможност
за действие) върху данните в набора.

* `iter` *заема*[^borrows] всеки член от набора при всяко повторение. Така
  наборът остава непроменен и може да се ползва след приключване на
  повторенията.

```rust,editable
fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter() {
        match name {
            &"Ferris" => println!("Има ръждар помежду ни!"),
            // ЗАДАЧА ^ Изтрийте  знака & и сравнете само с "Ferris"
            _ => println!("Здрасти {}", name),
        }
    }
    
    println!("names: {:?}", names);
}
```

* `into_iter` *употребява*[^consumes] набора, така че на всяка стъпка имаме на
  разположение самата стойност. След употребата наборът повече не може да се
  ползва, понеже бива *преместен*[^moved] вътре в цикъла.
```rust,editable,ignore,mdbook-runnable
fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.into_iter() {
        match name {
            "Ferris" => println!("Има ръждар помежду ни!"),
            _ => println!("Здрасти {}", name),
        }
    }
    
    println!("names: {:?}", names);
    // ПОПРАВИ ^ Коментирайте този ред
}
```

* `iter_mut` *заема* всеки член като менѝм и така позволява сбирката да бъде
  променяна на място.
```rust,editable
fn main() {
    let mut names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter_mut() {
        *name = match name {
            &mut "Ferris" => "There is a rustacean among us!",
            _ => "Hello",
        }
    }
    // Забележете, че всички стойности в `names` са променени според сравненията.
    println!("names: {:?}", names);
}
```

Обърнете внимание на начините, по които сравняваме стойностите в откъсите по-горе –
разклонението в `match`. Това е ключовата разлика между трите различни начина
за сравнение. Различният вид сравнение предполага възможност за извършване на
различни действия върху данните.

## Бел. прев.

[^iterator]: повторител – итератор – iterator

[^range]: редица (от .. до) – range; означението за редица – range notation

[^collection]: набор, сбирка, колекция – collection

[^borrows]: заема, взема на заем – borrows

[^consumes]: употребява (параметри, поредица, набор и т.н.) – consumes (parameters, array, collection etc.)

[^moved]: преместен – moved. Виж [Собственост и премествания][move]

### Вижте също:

[Iterator][iter]

[iter]: ../trait/iter.md
[move]: ../scope/move.md
