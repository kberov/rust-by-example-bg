# `Rc`

Когато ни е нужно повече променливи да владеят едно и също парченце данни,
можем да ползваме `Rc`(Reference Counting – Броене на Препратки – б. пр.). `Rc`
следи броя на препратките, което е броят на владелците на данните, обгърнати в
стойност от тип `Rc`. 

Броят на препратките се увеличава с единица (1) всеки път, когато една стойност
от тип `Rc` бива клонирана и намалява с единица, когато клонирана стойност от
тип `Rc` излезе от обхват. Когато борят на `Rc` препратките стане нула (което
означава, че не са останали владелци), `Rc` стойността и стойността, която тя
обгръща, биват освободени.

Клонирането на `Rc` стойност никога не прави дълбоко копиране. Клонирането
просто създава още един указател към обгърнатата стойност и увеличава бройката
на указателите към стойността.

```rust,editable
use std::rc::Rc;

fn main() {
    let rc_examples = "Rc examples".to_string();
    {
        println!("--- създаде се rc_a ---");
        
        let rc_a: Rc<String> = Rc::new(rc_examples);
        println!("Брой Препратки към rc_a: {}", Rc::strong_count(&rc_a));
        
        {
            println!("--- rc_a се клонира в rc_b ---");
            
            let rc_b: Rc<String> = Rc::clone(&rc_a);
            println!("Брой Препратки към rc_b: {}", Rc::strong_count(&rc_b));
            println!("Брой Препратки към rc_a: {}", Rc::strong_count(&rc_a));
            
            // Две `Rc` стойности са еднакви, ако техните вътрешни стойности са
            // еднакви
            println!("rc_a и rc_b са еднакви: {}", rc_a.eq(&rc_b));
            
            // Можем да ползваме методите на стойността непосредствено
            println!("Дължината на стойността в rc_a: {}", rc_a.len());
            println!("Стойността на rc_b: {}", rc_b);
            
            println!("--- rc_b е извън обхват (освободена е) ---");
        }
        
        println!("Брой Препратки към rc_a: {}", Rc::strong_count(&rc_a));
        
        println!("--- rc_a е извън обхват (освободена е) ---");
    }
    
    // Грешка! `rc_examples`  вече е преместена в `rc_a`
    // А когато `rc_a` бива освободена, `rc_examples` бива освободена с нея
    // println!("rc_examples: {}", rc_examples);
    // ЗАДАЧА^ Разкоментирайте този ред
}
```

### See also:

[std::rc][1] and [std::sync::arc][2].

[1]: https://doc.rust-lang.org/std/rc/index.html
[2]: https://doc.rust-lang.org/std/sync/struct.Arc.html
