# Параметри от призрачен тип

*Параметър от призрачен тип*[^phantom_type] е такъв, който не се появява по
време на изпълнение, а се проверява статично (и само) по време на компилиране.

Типовете данни могат да използват допълнителни обобщени типови параметри, които
да действат като означения или да извършват проверки на типове по време на
компилиране. Тези допълнителни параметри не съдържат съхранени стойности и не
правят нищо по време на изпълнение.

В следващия пример съвместяваме [std::marker::PhantomData] с идеята за параметър
от призрачен тип, за да създадем разнородни поредици, съдържащи различни типове данни.

```rust,editable
use std::marker::PhantomData;

// Списъчна структура от призрачен тип, обобщена през `A` със скрит
// параметър `B`.
#[derive(PartialEq)] // Разрешаваме проверка за еднаквост за този тип.
struct РазноПриз<A, B>(A, PhantomData<B>);

// Структура от призрачен тип, обобщена през `A` със скрит параметър `B`.
#[derive(PartialEq)] // Разрешаваме проверка за еднаквост за този тип.
struct ПризроСтрой<A, B> {
    first: A,
    phantom: PhantomData<B>,
}

// Важно: Заделено е място в паметта за обобщения тип `A`, но не и за `B`.
//        Затова `B` не може да се използва в изчисления.

fn main() {
    // Тук `f32` и `f64` са скритите параметри.
    // Типът за РазноПриз е уточнен като `<char, f32>`.
    let _tuple1: РазноПриз<char, f32> = РазноПриз('Q', PhantomData);
    // Типът за РазноПриз е уточнен като  `<char, f64>`.
    let _tuple2: РазноПриз<char, f64> = РазноПриз('Q', PhantomData);

    // Типът е уточнен като `<char, f32>`.
    let _struct1: ПризроСтрой<char, f32> = ПризроСтрой {
        first: 'Q',
        phantom: PhantomData,
    };
    // Типът е уточнен като `<char, f64>`.
    let _struct2: ПризроСтрой<char, f64> = ПризроСтрой {
        first: 'Q',
        phantom: PhantomData,
    };

    // Грешка по време на компилация за _tuple2! Разминаване в типовете –
    // променливите не могат да бъдат сравнени:
    // expected `РазноПриз<char, f32>`, found `РазноПриз<char, f64>`
    println!("_tuple1 == _tuple2 yields: {}", _tuple1 == _tuple2);

    // Грешка по време на компилация за _struct2! Разминаване в типовете –
    // променливите не могат да бъдат сравнени:
    // expected `ПризроСтрой<char, f32>`, found `ПризроСтрой<char, f64>`
    println!("_struct1 == _struct2 yields: {}", _struct1 == _struct2);
}
```

# Б.пр.

[^phantom_type]: параметър от призрачен тип – phantom type parameter.
 В примера отново използваме азбука, за да покажем поддръжката на Ръждьо за
 уникод и по-ясно да различм внесения PhantomData от нашите потребителски
 типове, които можем да наречем всякак.

### See also:

[Derive], [struct] и [TupleStructs]

[Derive]: ../trait/derive.md
[struct]: ../custom_types/structs.md
[TupleStructs]: ../custom_types/structs.md
[std::marker::PhantomData]: https://doc.rust-lang.org/std/marker/struct.PhantomData.html
