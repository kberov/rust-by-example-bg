# Единосъщност

Чрез обвързване с имена (каквото са променлвите), данните могат да бъдат
заемани менимо многократно, но докато са заети неменимо не могат да бъдат
заемани менимо. Освен това може да има само _едно_ менимо заемане едновременно.
Първоначалните данни може да се заемат отново само _след като_ менимата
препратка е използвана за последен път.

```rust,editable
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    let borrowed_point = &point;
    let another_borrow = &point;
    // Данните могат да бъдат достъпени чрез препратки и чрез първоначалния
    // владелец
    println!(
        "Point has coordinates: ({}, {}, {})",
        borrowed_point.x, another_borrow.y, point.z
    );

    // Грешка! Не може да се заеме `point` като менима, защото сега е заета
    // като неменѝма
    // let mutable_borrow = &mut point;
    // ЗАДАЧА^ Разкоментирайте този ред

    // Заетите данни биват ползвани отново тук
    println!(
        "Point has coordinates: ({}, {}, {})",
        borrowed_point.x, another_borrow.y, point.z
    );

    // Неменимите препратки не се ползват по-нататък в кода, следователно може
    // да бъдат заети отново чрез менима препратка.
    let mutable_borrow = &mut point;

    // Променяме данните чрез менима препратка
    mutable_borrow.x = 5;
    mutable_borrow.y = 2;
    mutable_borrow.z = 1;

    // Грешка! Не може да се заеме `point` като неменѝма, защото сега е заета
    // като менѝма.
    // let y = &point.y;
    // ЗАДАЧА^ Разкоментирайте този ред

    // Грешка! Не може да се печати, защото `println!` взема неменѝма препратка,
    // а по-долу в кода се ползва `mutable_borrow` – менима препратка.
    // println!("Point Z coordinate is {}", point.z);
    // ЗАДАЧА^ Разкоментирайте този ред

    // Може! Менѝми препратки може да се подават като неменѝми на `println!`
    println!(
        "Point has coordinates: ({}, {}, {})",
        mutable_borrow.x, mutable_borrow.y, mutable_borrow.z
    );

    // Менимата препратка вече не се използва до края на кода, значи може
    // данните да се заемат отново.
    let new_borrowed_point = &point;
    println!(
        "Point now has coordinates: ({}, {}, {})",
        new_borrowed_point.x, new_borrowed_point.y, new_borrowed_point.z
    );
}

```

## Б.пр.

В Ръждьо за _единосъщни_[^aliasing] се смятат две променливи, които сочат към
едни и същи данни в паметта. В следването на собствените си правила за
безопаснот, Ръждьо не позволява едновременно писане в две променливи, които
сочат към едни и същи данни, макар да са с различни имена. Тогава едната
променлия се счита за друго име (прякор, псевдоним) на другата.
От [„The Rustonomicon”](https://doc.rust-lang.org/nomicon/aliasing.html):
„…variables and pointers alias if they refer to overlapping regions of memory.”
– Променливите и указателите с две различни имена имена са единосъщни,
ако препращат към припокриващи се области от паметта.

[^aliasing]: единосъщност,  разнооименност – aliasing

