# Обвързване

При косвения достъп до променливи (съответно сравнение чрез буквални стойности)
е невъзможно в разклонението да се използва тази променлива (или стойност)
без обвързване наново. `match` предоставя знака `@` за обвързване на определени
стойности с имена на променливи:

```rust,editable
// Функция `age`, връщаща стойност от тип `u32`.
fn age() -> u32 {
    15
}

fn main() {
    println!("Кажете на каква възраст сте.");

    match age() {
        0 => println!("Все още не съм отпразнувало първия си рожден ден"),
        // можехме направо да сравним 1 ..= 12, но тогава на каква възраст би
        // било едно новородено? Затова обвързваме `n` с последователността
        // 1 ..= 12. Сега можем да кажем каква е възрастта.
        n @ 1  ..= 12 => println!("Аз съм дете на {:?} години", n),
        n @ 13 ..= 19 => println!("Аз съм младеж на {:?} години", n),
        // Нищо не е обвързано (изрично). Връщаме стойността.
        n => println!("Аз съм възрастен на {:?} години", n),
    }
}
```

Можете да ползвате обвързване за разлагане на варианти на броители, например `Option`:

```rust,editable
fn some_number() -> Option<u32> {
    Some(42)
}

fn main() {
    match some_number() {
        // Даденият вариант `Some` съвпада, ако стойността му, обвързана с `n`,
        // е равна на 42.
        Some(n @ 42) => println!("Отговор: {}!", n),
        // Съвпадение с някое друго число.
        Some(n)      => println!("Безинтересно... {}", n),
        // Съвпадение с нещо друго (вариант `None`).
        _            => (),
    }
}
```

### Вижте също:
[функции][functions], [броители][enums] и [`Option`][option]

[functions]: ../../fn.md
[enums]: ../../custom_types/enum.md
[option]: ../../std/option.md
