# Функции

Без оглед на [пропускането][elision], обявите на функциите с живот имат някои
ограничения:
* всяка препратка _задължително трябва_ да е с отбелязан живот.
* всяка върната препратка _задължително трябва_ да има същия живот като на
  входните данни (параметъра), или животът ѝ да бъде `static`.

В допълнние, обърнете внимание, че връщането на препратки е забранено, ако това
ще доведе до връщане на недействителни данни. Следващият пример показва няколко
работещи рановидности на функции с указана продължителност на живота.

```rust,editable
// Една входна препратка с живот `'a`, която трябва да живее поне колкото
// функцията.
fn print_one<'a>(x: &'a i32) {
    println!("`print_one`: x is {}", x);
}

// Също може да се приемат меними препратки с указан живот.
fn add_one<'a>(x: &'a mut i32) {
    *x += 1;
}

// Повече аргументи с различен живот. В този случай и двата аргумента биха
// могли да имат един и същи живот `'a`, но при по-сложни случаи може да се наложи
// да са с различни животи.
fn print_multi<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("`print_multi`: x is {}, y is {}", x, y);
}

// Да се връщат приети като аргументи препратки е приемливо.
// Но трябва да се върне правилния живот.
fn pass_x<'a, 'b>(x: &'a i32, _: &'b i32) -> &'a i32 { x }

//fn invalid_output<'a>() -> &'a String { &String::from("foo") }
// Горното не работи: `'a` трябва да живее по-дълго от функцията.
// Тук `&String::from("foo")` ще създаде обект `String`, следван от препратка.
// След което данните се изхвърлят при излизане от обхват, като така остава за
// връщане препратка към недействителни данни.

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&x);
    print_multi(&x, &y);
    
    let z = pass_x(&x, &y);
    print_one(z);

    let mut t = 3;
    add_one(&mut t);
    print_one(&t);
}
```
### Вижте също:

[Функции]

[Функции]: ../../fn.md

[elision]: elision.md
