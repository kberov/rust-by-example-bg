# Като входни параметри

Ръждьо избира как да прихваща променливи в движение и почти без да е нужно
отбелязване на типа. Тази неопределеност не се позволява, когато пишем функции.
Когато се приема затваряне като входен параметър, трябва да се укаже пълният тип
на затварянето, като се използва някой от наличните вече отличители.
Отличителят се определя от това, какво прави затварянето с прихванатите
стойности.

Ето кои са те, по ред на намаляване на ограниченията.

* `Fn`: прихванатите стойности се използват като препратки (`&T`)
* `FnMut`: прихванатите стойности се използват като меними препратки (`&mut T`)
* `FnOnce`: прихванатите стойности се използват като стойности (`T`)

Компилаторът ще прихване променливите по възможно най-малко ограничаващия начин. Това се прави променлива по променлива.

Нека разгледаме един параметър, отбелязан като `FnOnce`. Това указва, че
затварянето *би могло* да прихване околните променливи като `&T`, `&mut T`, или
`T`, но компилаторът в крайна сметка ще избере в зависимост от начина на
използване на променливите в затварянето.

Това е така, защото е възможно да се случи преместване на стойността, тогава
също ще е възможно заемането на всеки тип. Забележете, че обратното не е вярно.
Ако параметърът е отбелязан като `Fn`, тогава прихващане на променливи като
`&mut T` или `T` е невъзможно. Само прихващане като `&T` е позволено.

В следващия пример заменете използвания отличител с `Fn`, `FnMut` и `FnOnce`,
за да видите какво се случва: 

```rust,editable
// Функция, която приема затваряне като аргумент и го извиква.
// <F> означава, че F е „параметър с обобщен тип”
fn apply<F>(f: F) where
    // Зтварянето не приема нищо и не връща нищо.
    F: FnOnce() {
    // ^ ЗАДАЧА: Променете това на `Fn` или `FnMut`.

    f();
}

// Функция, която приема затваряне и връща `i32`.
fn apply_to_3<F>(f: F) -> i32 where
    // Затварянето приема `i32` и връща `i32`.
    F: Fn(i32) -> i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = "здравей";
    // Некопируем тип.
    // `to_owned` създава собствени данни от заети данни
    let mut farewell = "довиждане".to_owned();

    // Прихващаме 2 променливи: `greeting` като препратка и `farewell` като
    // стойност.
    let diary = || {
        // `greeting` е препратка: изисква `Fn`.
        println!("Аз казах {}.", greeting);

        // Промяната прави `farewell` да бъде прихваната като менима препратка
        // Сега е нужен `FnMut`.
        farewell.push_str("!!!");
        println!("После изкрещях {}.", farewell);
        println!("Сега мога да поспя. zzzzz");

        // Ако извикаме `drop` ръчно, `farewell` ще бъде прихваната като
        // стойност. Сега ни трябва `FnOnce`.
        mem::drop(farewell);
    };

    // Извикваме функцията, която прилага затварянето.
    apply(diary);

    // `double` удовлетворява ограниченията на отличителя за `apply_to_3`
    let double = |x| 2 * x;

    println!("Удвоено 3: {}", apply_to_3(double));
}
```

### See also:

[`std::mem::drop`][drop], [`Fn`][fn], [`FnMut`][fnmut], [Generics][generics], [where][where] и [`FnOnce`][fnonce]

[drop]: https://doc.rust-lang.org/std/mem/fn.drop.html
[fn]: https://doc.rust-lang.org/std/ops/trait.Fn.html
[fnmut]: https://doc.rust-lang.org/std/ops/trait.FnMut.html
[fnonce]: https://doc.rust-lang.org/std/ops/trait.FnOnce.html
[generics]: ../../generics.md
[where]: ../../generics/where.md
