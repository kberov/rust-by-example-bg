# Безименен тип

Затварянията прихващат променливи от околния код. Какви са последствията от
това? Обърнете внимание, че когато използваме затваряне като параметър на
функция, е нужно да използваме *[обобщения]*. Това е необходимо заради начина, по
който се описват затварянията: 

```rust
// `F` must be generic.
fn apply<F>(f: F) where
    F: FnOnce() {
    f();
}
```
Когато описваме затваряне, компилаторът неявно създава нова безименна
структура, в която да съхранява прихванатите променливи, като същевременно
осъществява нужната функционалност за този нов безименен тип чрез един от
отличителите `Fn`, `FnMut` или `FnOnce`. Този тип бива присвоен на
променлива, която се пази до извикване на затварянето.

Понеже този нов тип е непознат, всяко използване във функция ще изисква *обобщен
тип*. Обаче един неограничен по тип параметър `<T>` ще си е все така нееднозначен и
затова забранен. Така че ограничаването до един от отличителите `Fn`, `FnMut`
или `FnOnce` (които затварянето осъществява) е достатъчно за указване на типа
му.

```rust,editable
// `F` трябва да осъществява `Fn` за затваряне, което не приема входни
// параметри и не връща нищо – точно каквото е нужно за `print`.
fn apply<F>(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // Прихващаме `x` в безименен тип и осъществяваме `Fn` за него. 
    // Съхраняваме го в `print`.
    let print = || println!("{}", x);

    apply(print);
}
```

### Вижте също:

[Подробен разбор][thorough_analysis], [`Fn`][fn], [`FnMut`][fn_mut]
и [`FnOnce`][fn_once]

[обобщения]: ../../generics.md
[fn]: https://doc.rust-lang.org/std/ops/trait.Fn.html
[fn_mut]: https://doc.rust-lang.org/std/ops/trait.FnMut.html
[fn_once]: https://doc.rust-lang.org/std/ops/trait.FnOnce.html
[thorough_analysis]: https://huonw.github.io/blog/2015/05/finding-closure-in-rust/
