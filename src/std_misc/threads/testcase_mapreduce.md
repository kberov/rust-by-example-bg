# Проверка: map-reduce[^map_reduce]

С Ръждьо много лесно се прави успоредна обработка на данни без обичайните
затруднения, с които сме свикнали при такива начинания.

Стандартната библиотека предоставя чудеснни първични типове за
многонишковост[^threading] наготово. Тези типове, съчетани с правилата за
[единосъщност] и владеене на променливите, автоматично предотвратяват _гонките
за данни_[^data_races].

Правилата за _единосъщност на данните_[^aliasing] (само една менима препратка
или (XOR (изключващо или)) много неменими препратки) автоматично предотвратяват
вероятността да се промени състояние на данните, което е видимо и за други
нишки. Когато е нужна синхронизация при промяна на данните, стандартната
библиотека предоставя първични типове за синхронизация като `Mutex` и
`Channel`.

В този пример ще изчислим сумата на всички цели числа в един блок. Ще направим
това като разделим на парчета блока в различни нишки. Всяка нишка ще изчисли
сумата на нейния си подблок от числа. После ще съберем получените междинни
суми, изчислени от всяка ниша.

Забележете, че макар да подаваме препратки отвъд границите на нишките, Ръждьо
разбира, че подаваме препратки само за четене и така няма опасност от гонки за
данните. Освен това, тъй като подаваните препратки имат `'static` живот, Ръждьо
разбира, че данните няма да бъдат унищожени, докато работят тези нишки. (Когато
искаме да споделяме данни с не-`'static` живот между нишките, можем да ползваме
умен указател като `Arc`, за да държим данните живи и така да избегнем
употребата на не-`static` животи.)

```rust,editable
use std::thread;

// Това е главната нишка.
fn main() {

    // Това са нашите данни за обработка.
    // Ще изчислим сбора на всички числа чрез многонишков алгоритъм, наречен
    // "map-reduce". Всяко парче, отделено от другите с празнота ще бъде
    // обработено в отделна нишка.
    //
    // ЗАДАЧА: Вижте какво се случва с изхода, ако въведете празноти между
    // някои числа!
    let data = "86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668";

    // Създаваме вектор да държи новосъздадените дъщерни нишки.
    let mut children = vec![];

    /*************************************************************************
     * Стъпка "Map"
     *
     * Разделяме данните на парчета и прилагаме предварителна обработка
     ************************************************************************/

    // Разделяме данните на дялове за самостоятелно изчисляване. Всяко парче ще
    // бъде препратка (&str) към истинските данни.
    let chunked_data = data.split_whitespace();

    // Обхождаме парче по парче данните.
    // .enumerate() добавя текущия показалец от повторението към каквото се
    // обхожда. Произведената разнородна поредица "(index, element)" бива
    // незабавно разложена в две променливи – "i" и "data_segment" чрез
    // присвояване.
    for (i, data_segment) in chunked_data.enumerate() {
        println!("Парчето данни  {} е \"{}\"", i, data_segment);

        // Обработваме всяко парче в отделна нишка.
        //
        // spawn() връща ръкохватка за новата нишка, която ТРЯБВА да запазим,
        // за да достъпим върнатата стойност.
        //
        // 'move || -> u32' е правопис за затваряне, който:
        // * не приема аргументи ('||'),
        // * овладява прихванатите стойности ('move') и
        // * връща 32-битово цяло число без знак ('-> u32')
        //
        // Ръждьо е достатъчно умен да отгатне '-> u32' от затварянето, така,
        // че можеше даже да не го указваме изрично.
        //
        // ЗАДАЧА: Махнете 'move' и вижте какво се случва.
        children.push(thread::spawn(move || -> u32 {
            // Изчисляваме междинната сума от този участък:
            let result = data_segment
                        // Обхождаме знаците от текущия участък…
                        .chars()
                        // …превръщаме знаците в цели десетични числа…
                        .map(|c| c.to_digit(10).expect("трябва да е число"))
                        // …и сумираме произведения повторител на числа
                        .sum();

            // println! заключва стандартния изход и така няма смесен изход от
            // различни нишки.
            println!("обработиме участък {}, сума={}", i, result);

            // Не ни е нужен израз "return", защото Ръждьо е "ѝзразен език",
            // последно изчисления израз във всеки блок става автоматично стойност
            // за връщане.
            result

        }));
    }


    /*************************************************************************
     * Стъпка "Reduce"
     *
     * Събираме междинните суми и ги сумираме като краен резултат.
     ************************************************************************/

    // Използваме „турбофиш” (::<>), за да подскажем типа за окончателната сума.
    //
    // ЗАДАЧА: Опитайте без „турбофиш”, като вместо това укажете типа за
    // final_result изрично.
    let final_result = children.into_iter().map(|c| c.join().unwrap())
        .sum::<u32>();

    println!("Окончателна сума: {}", final_result);
}
```

### Упражнения
Не е мъдро броят на нишките да зависи от входните данни. Какво ако потребителят
реши да въведе празноти[^spaces] между много числа? Наистина ли искаме да
създадем 2000 нишки? Променете програмата, така че данните да се разделят в
ограничен брой парчета, определящи се от статична константа в началото на
програмата.

## Б.пр.

[^map_reduce]: съответствие-намаляване map-reduce? ЗАДАЧА: да се преведе и
  обясни на български: https://en.wikipedia.org/wiki/MapReduce
  https://ru.wikipedia.org/wiki/MapReduce

[^threading]: нишковост – threading; многонишковост – multi-threading

[^data_races]: гонки за данни – data races

[^aliasing]: единосъщност, разноименост – aliasing. Когато различни променливи
  сочат към едни и същи данни. Ръждьо автоматично (по подразбиране) не
  позволява това да се случи.

[^spaces] празнота, празно пространство – space, white-space

### See also:
* [Нишки][thread]
* [Вектори][vectors] и [Повторители][iterators]
* [Затваряния][closures], [move][move] semantics и [`move` closures][move_closure]
* Присвояване чрез [разлагане][destructuring]
* [означение турбофиш][turbofish] за помощ при отгатване на типове
* [unwrap с/у expect][unwrap]
* [enumerate][enumerate]


[единосъщност]: ../../scope/borrow/alias.md
[thread]: ../threads.md
[vectors]: ../../std/vec.md
[iterators]: ../../trait/iter.md
[destructuring]: https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values
[closures]: ../../fn/closures.md
[move]: ../../scope/move.md
[move_closure]: https://doc.rust-lang.org/book/ch13-01-closures.html#closures-can-capture-their-environment
[turbofish]: https://doc.rust-lang.org/book/appendix-02-operators.html?highlight=turbofish
[unwrap]: ../../error/option_unwrap.md
[enumerate]: https://doc.rust-lang.org/book/loops.html#enumerate
