#  Низове

В Ръждьо има два типа низове: `String` и `&str`.

Типът (`String`) се съхранява като вектор от байтове (`Vec<u8>`), но е
гарантирано, че винаги ще бъде действителна UTF-8 последователност. Низовете се
съхраняват в купа, могат да растат и не завършват с празен байт (\0).

Типът `&str` е отрязък (`&[u8]`), който винаги сочи към действителна UTF-8
последователност, и може да се ползва за „поглеждане (четене)” в стойност от тип
`String`, точно както `&[T]` е _изглед_[^view] във `Vec<T>`.

```rust,editable
fn main() {
    // (всички отбелязвания на типове са излишни)
    // Препратка към низ, поместен в статичната памет (само за четене)
    let pangram: &'static str = "Хм, чужд щит, бърз гьон плюс яйце в шкаф.";
    println!("Панграм: {}", pangram);

    // Обхождаме думите наобратно, не се създава нов низ в паметта
    println!("Думите наобратно");
    for word in pangram.split_whitespace().rev() {
        println!("> {}", word);
    }

    // Копираме знаци във вектор, подреждаме по азбучен ред и премахваме
    // повтарящите се
    let mut chars: Vec<char> = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // Създаваме празен низ с променлива дължина
    let mut string = String::new();
    for c in chars {
        // Добавяме знак в края на низа
        string.push(c);
        // Добавяме низ в края на низа
        string.push_str(", ");
    }

    // Окастреният низ е отрязък от първоначалния низ, сиреч няма ново
    // поместване в паметта.
    let chars_to_trim: &[char] = &[' ', ','];
    let trimmed_str: &str = string.trim_matches(chars_to_trim);
    println!("Използвани знаци: {}", trimmed_str);

    // Поместване на низ в купа
    let alice = String::from("Харесвам кучета");
    // Заделяме нова памет и съхраняваме променения низ там
    let bob: String = alice.replace("кучета", "котки");

    println!("Алис казва: {}", alice);
    println!("Боб казва: {}", bob);
}
```

Още методи на `str`/`String` могат да се видят в модулите [std::str][str] и
[std::string][string].

## Буквални стойности и избягване[^escape]

Има няколко начина да се пишат низови буквални стойности с особени
знаци[^spec_chars] в тях. Всички биват създадени като `&str`, така че може да
се въвеждат както ви е най-удобно. Също така има няколко начина да се пишат
байтови низови буквални стойности, който се създават като `&[u8; N]`.

Обичайно особените знаци се избягват с обратно наклонена черта: `\`. Така можем
да добавим всякакъв знак към низ, дори непечатаеми и такива, които не знаем как
да въведем. Ако искаме да въведем обратно наклонена черта, я избягваме с още
една пред нея: `\\`.

Низовите или знакови разделители в буквална стойност трябва да се избягват с
обратно наклонена черта: `"\""`, `'\''`.

```rust,editable
fn main() {
    // Можем да ползваме избягване, за да пишем байтове като ползваме
    // шестнадесетичните им стойности…
    let byte_escape = "I'm writing \x52\x75\x73\x74!";
    println!("What are you doing\x3F (\\x3F means ?) {}", byte_escape);

    // …или кодови точки от Уникод.
    let unicode_codepoint = "\u{211D}";
    let character_name = "\"DOUBLE-STRUCK CAPITAL R\"";

    println!("Знакът от Уникод таблицата {} (U+211D) се нарича {}",
                unicode_codepoint, character_name );


    let long_string = "Низовите буквали
                        могат да се пишат на повече редове.
                        Краят на реда и отстъпа тук ->\
                        <- могат също да се избегнат!";
    println!("{}", long_string);
}
```

Понякога има много знаци за избягване или е много по-удобно да напишем низа
така както е. Тук е мястото да се ползват сурови низови буkвални
стойности[^raw_str].

```rust, editable
fn main() {
    let raw_str = r"Тук избягванията не работят: \x3F \u{211D}";
    println!("{}", raw_str);

    // Ако искаме кавички в суров низ, трябва да го оградим с # около
    // ограждащите кавички.
    let quotes = r#"И тогава си казах: "Няма спасение!""#;
    println!("{}", quotes);

    // Ако ни трябва "#, просто ползваме повече диези (#) за ограждане.
    // Диезите могат да бъдат до 65535.
    let longer_delimiter = r###"Низ с "# в него. И после даже "##!"###;
    println!("{}", longer_delimiter);
}
```

Искаме низ, който не е кодиран като UTF-8? (Да не забравяме, `str` и `String`
трябва да са действителни UTF-8). Или може би искаме поредица от байтове, която
е почти само текст? Байтовите низове са нашето спасение!

```rust, editable
use std::str;

fn main() {
    // Забележете, че това всъщност не е `&str`
    let bytestring: &[u8; 21] = b"this is a byte string";

    // Байтовите поредици не не осъщетвяват отличителя `Display`, затова
    // печатането им е малко ограничено
    println!("Низ от байтове: {:?}", bytestring);

    // В байтовите низове може да има избягвания…
    let escaped = b"\x52\x75\x73\x74 as bytes";
    // …но не и знаци от уникод
    // let escaped = b"\u{211D} is not allowed";
    println!("Някои избегнати байтове: {:?}", escaped);


    // Суровите байтови низове работят точно като суровите низове
    let raw_bytestring = br"\u{211D} is not escaped here";
    println!("{:?}", raw_bytestring);

    // Превръщането на байтова поредица в `str` може да се провали
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!("И същото като текст: '{}'", my_str);
    }

    let _quotes = br#"You can also use "fancier" formatting, \
                    like with normal raw strings"#;

    // Суровите низове не трябва задължително да са UTF-8
    // "ようこそ" в кодова таблица SHIFT-JIS
    let shift_jis = b"\x82\xe6\x82\xa8\x82\xb1\x82\xbb";

    // Но не винаги могат да бъдат превърнати в `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) => println!("Превръщането е успешно: '{}'", my_str),
        Err(e) => println!("Превръщането не успя: {:?}", e),
    };
}
```

За превръщане между знакови кодирания, прегледайте коша
[encoding][encoding-crate].

По-подробен списък с описания на начините да се пишат буквални низови
стойности и знаци за избягване е даден в главата [„Признаци”][tokens][^token]
на „Справочника на Ръждьо”.


## Б.пр.

[^view]: изглед – view

[^spec_chars]: особени знаци – special characters

[^escape]: избягване – escape. Избягва се знак, който искаме да се покаже по
  различен начин от начина, по който иначе би бил показан без да се постави `\`
  пред него.

[^raw_str]: сурови низови буkвални стойности – raw string literals

поместване в паметта, заделяне на памет – allocation

панграм – Панграмата ((ж. грамат. р.), наричана още панграм (pangram) (м. грамат. р.), от
гръцки: παν γράμμα, pan gramma, „всяка буква“) е изречение, включващо всички
букви (глифи/глифове) от дадена азбука (например българската, английската
латиница или гръцката).

[^token] признак – token


[str]: https://doc.rust-lang.org/std/str/
[string]: https://doc.rust-lang.org/std/string/
[tokens]: https://doc.rust-lang.org/reference/tokens.html
[encoding-crate]: https://crates.io/crates/encoding
