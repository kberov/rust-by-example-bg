# Изрично отбелязване

Проверителят за заемки използва изричното отбелязване на живота, за да определи
колко дълго са в сила препратките. В случаите, когато животите са изрично
указани (не са пропуснати[^elided]|[^elision]), Ръждьо изисква изрично отбелязване,
за да определи какъв би трябвало да е животът на дадена препратка.  Правописът
за указване на живот е с апостроф. Ето така: 

```rust,ignore
foo<'a>
// `foo` има параметър за живот `'a`
```

Подобно на [затварянията][anonymity], използването на животи изисква обобщения.
В допълнение този правопис за живот означава, че животът на `foo` не може да
надвишава този на `'a`. Изричното обозначаване на тип има вида `&'a T`, като
`'a` вече е било въведено в употреба.

Когато имаме множество животи, правописът е подобен:

```rust,ignore
foo<'a, 'b>
// `foo` има параметри за живот за `'a` и `'b`
```

В този случай животът на `foo` не може да надвишава този на `'a` *или* `'b`.

Да разгледаме следния пример за изрично обозначаване на живот:

```rust,editable,ignore,mdbook-runnable
// `print_refs` приема две препратки към данни от тип `i32`, които имат
// различни животи `'a` и `'b`. Тези два живота трябва да са с продължителност
// поне колкото на функцията `print_refs`.
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("x is {} and y is {}", x, y);
}

// Функция, която не приема аргументи, но има праметър за живот `'a`.
fn failed_borrow<'a>() {
    let _x = 12;

    // Грешка!: `_x` не живее достатъчно дълго
    let y: &'a i32 = &_x;
    // Опитът да се ползва живот `'a` като изрично отбелязване за тип вътре във
    // функцията дава грешка, защото животът на `&_x` е по-къс от този на `y`. Къс
    // живот не може насила да бъде приведен³ към по-дълъг.
}

fn main() {
    // Създаваме променливи, за да бъдат заети по-долу.
    let (four, nine) = (4, 9);
    
    // Заети препратки (`&`) и на двете променливи са подадени във функцията.
    print_refs(&four, &nine);
    // Всяка заета входна променлива трябва да надживее заемащия. Иначе
    // казано, животът на `four` и `nine` трябва да е по-дълъг от този на
    // `print_refs`.
    
    failed_borrow();
    // `failed_borrow` не съдържа препратка, за да насили `'a` да бъде по-дълъг
    // от живота на функцията, но `'a` е по-дълъг. Понеже животът не е ограничаван
    // никога, той по подразбиране е `'static`.
}
```

## Б.пр.

[^elided]: неявно указан, пропуснат – elided (elision) 

[^elision]: неявно указване, пропускане – elision. [Пропускането][elision], отбелязва животите неявно, така че е нещо различно.

[^coercion]: мълчаливо привеждане насила (от един тип към друг) – coercion 

### Вижте също:

[generics][generics] and [closures][closures]

[anonymity]: ../../fn/closures/anonymity.md
[closures]: ../../fn/closures.md
[elision]: elision.md
[generics]: ../../generics.md
