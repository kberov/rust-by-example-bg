# Прихващане

Затварянията са много гъвкави и правят всичко възможно да си вършат работата
без допълнителни указания. Това позволява прихващането на променливи да бъде
нагаждано според както е необходимо – чрез *преместване* или чрез *заемане*.
Затварянията могат да прихващат променливи като:

* препратки: `&T`
* меними препратки: `&mut T`
* стойност: `T`

Променливите биват прихващани най-вече като препратки, а другояче – само
по необходимост.

```rust,editable
fn main() {
    use std::mem;
    
    let color = String::from("green");

    // Затваряне, отпечатващо `color`, което незабавно заема (`&`) `color`.
    // Заетото и затварянето се съхраняват в променливата `print`.
    // Променливата остава заета, до посленото извикване на `print`. 
    //
    // `println!` изисква аргументи само като неменими препратки, така че
    // не налага допълнителни ограничения.
    let print = || println!("`color`: {}", color);

    // Извикваме затварянето, използвайки заетата променлива.
    print();

    // `color` може да бъде заета отново, защото `print` държи само неменима
    // препратка към `color`. 
    let _reborrow = &color;
    print();

    // пресместване или заемане на `color` отново е разрешено след последното
    // ползване на `print`
    let _color_moved = color;


    let mut count = 0;
    // Затваряне, което да увеличи стойността на `count` може да заеме `&mut
    // count` или `count`, но `&mut count` е по-малко ограничаващо, така че прави
    // това. Незабавно заема `count`.
    //
    // Задължително е `inc` да е `mut`, защото съхраняваме в него менима
    // препратка (`&mut`). Като извикваме затварянето, ние го променяме и
    // затова трябва да го опишем като менимо – `mut`.
    let mut inc = || {
        count += 1;
        println!("`count`: {}", count);
    };

    // Извикваме затварянето, използвайки менима заемка.
    inc();

    // Затварянето `inc` все още заема `count` като менима променлива, защото
    // се извиква отново по-късно.
    // Ако се опитаме да я заемем пак, това ще доведе до грешка.
    // let _reborrow = &count; 
    // ^ ЗАДАЧА: разкоментирайте този ред.
    inc();

    // `inc` вече не заема `&mut count`. Затова можем да я заемем без грешка.
    let _count_reborrowed = &mut count; 

    
    // Некопируем тип
    let movable = Box::new(3);

    // `mem::drop` изисква `T`, така, че следващият код ще прихване `movable`
    // по стойност (ще го премести вътре в затварянето). Ако типа беше
    // копируем, щеше да се копира в затварянето, а първоизточникът да си
    // остане недокоснат.
    // Некопируем тип задължително бива преместен и затова `movable` незабавно
    // се мести в затварянето.
    let consume = || {
        println!("`movable`: {:?}", movable);
        mem::drop(movable);
    };

    // `consume` изяжда променливата, затова може да бъде извикана само веднъж.
    consume();
    // consume();
    // ^ ЗАДАЧА: разкоментирайте този ред.
}
```

Ако напишем `move` преди отвесните чертички, караме затварянето да овладее
прихванатите променливи:

```rust,editable
fn main() {
    // `Vec` е некопируем.
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);

    println!("{}", contains(&1));
    println!("{}", contains(&4));

    // println!("There're {} elements in vec", haystack.len());
    // ^ Ако разкоментирате горния ред, ще получите грешка при компилацията,
    // защото проверителят на заемите не позволява повторното използване на
    // променливи, след като са преместени.
    
    // Ако премахнете `move` от обявлението на затварянето, то ще заеме
    // haystack като неменима препратка, така че haystack ще може да се ползва.
    // Тогава, ако разкоментирате реда с println! по-горе, няма да има грешка.
}
```

### Вижте също:

[`Box`][box] и [`std::mem::drop`][drop]

[box]: ../../std/box.md
[drop]: https://doc.rust-lang.org/std/mem/fn.drop.html
