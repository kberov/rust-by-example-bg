# Превръщане на типове

Ръждьо няма мълчаливо превръщане насила[^coercion] между първичните типове. Но
изрично превръщане[^casting] може да се прави с помощта на ключовата дума `as`.

Правилата за превръщане между целочислените стойности следват тези в C като
цяло освен в случаите, където в C поведенеието е неопределено. Поведението при
превръщане между всички целочислени типове е строго определено в Ръждьо.

```rust,editable,ignore,mdbook-runnable
// Подтискаме всички предупреждения за препълващи превръщания.
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // Грешка! Няма мълчаливо превръщане
    let integer: u8 = decimal;
    // ПОПРАВИМЕ ^ Да се коментира този ред

    // Изрично превръщане
    let integer = decimal as u8;
    let character = integer as char;

    // Грешка ! Има някои ограничения при превръщане.
    // Число с плаваща запетая не може да се превърне
    // направо в писмен знак `char`.
    let character = decimal as char;
    // ПОПРАВИМЕ ^ Да се коментира този ред

    println!("Превръщане: {} -> {} -> {}", decimal, integer, character);

    // Когато се превръща каквато и да е стойност към тип без знак, T,
    // T::MAX + 1 се добавя докато стойността не се побере в новия тип.

    // 1000 се побира в u16
    println!("1000 като u16 е: {}", 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // Подробности: първите 8 най-малко значими (младши) битове (LSB) се
    // запазват, а старшите (MSB) се орязват.
    println!("1000 като u8 е : {}", 1000 as u8);
    // -1 + 256 = 255
    println!("  -1 като u8 е : {}", (-1i8) as u8);

    // За положителни числа това е същото като получаване на остатък
    println!("Остатꙑкът от 1000, делено на 256, е: {}", 1000 % 256);

    // Когато превръщаме към тип със знак, побитовия резултат е същият като
    // първото преобразуване към съответстващия тип без знак. Ако най-значимият
    // бит на стойността е 1, то стойността е отрицателна.

    // Освен, разбира се, когато стойността се побира в типа.
    println!(" 128 като i16 е: {}", 128 as i16);

    // В граничния случай стойността 128 в 8 бита two's complement representation is -128
    println!(" 128 as a i8 is : {}", 128 as i8);

    // повтаряме примера от горе
    // 1000 като u8 -> 232
    println!("1000 като u8 е : {}", 1000 as u8);
    // и стойностт на 232 в 8 бита two's complement representation is -24
    println!(" 232 as a i8 is : {}", 232 as i8);

    // От Ръждьо 1.45, ключовата дума `as` работи като *наситено превръщане*,
    // когато превръщаме от тип с плаваща запетая към целочислен тип. Ако
    // дробната стойност надвишава горната граница или е по-малка от долната
    // граница, върнатата стойност ще бъде равна на прескочената граница.

    // 300.0 като u8 е 255
    println!(" 300.0 като u8 е: {}", 300.0_f32 as u8);
    // -100.0 като u8 е 0
    println!("-100.0 като u8 е: {}", -100.0_f32 as u8);
    // NAN като u8 е 0
    println!(" НАН   като u8 е: {}", f32::NAN as u8);

    // Това поведение има малка цена по време на изпълнение и може да бъде
    // избегнато чрез опасни методи. Обаче резултатът може да прелее и да върне
    // **безсмислени** стойности. Използвайте тези методи разумно.
    unsafe {
        // 300.0 като u8 е 44
        println!(" 300.0 като u8 е : {}", 300.0_f32.to_int_unchecked::<u8>());
        // -100.0 като u8 е 156
        println!("-100.0 като u8 е : {}", (-100.0_f32).to_int_unchecked::<u8>());
        //  NАН като u8 е 0
        println!("   NAN като u8 е : {}", f32::NAN.to_int_unchecked::<u8>());
    }
}
```

[^coercion]: мълчаливо превръщане насила (между първичните типове) – coercion 

[^casting]: изрично превръщане – casting
