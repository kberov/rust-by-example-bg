# Указатели и `ref`

За указателите трябва да се прави разлика между разлагане и *пряк достъп*[^dereferencing], тъй като те са различни понятия, които се
ползват по различен начин от езици като C/C++.

 * При дереферирането ползваме знака `*`
 * При разлагане ползваме `&`, `ref` и `ref mut`

```rust,editable
fn main() {
    // Обвързваме препратка към данни от тип `i32`. `&` означава, че
    // присвояваме препратка.
    let reference = &4;

    match reference {
        // Ако `reference` се сравни с `&val`, сравнението е:
        // `&i32`
        // `&val`
        // ^ Виждаме, че ако махнем `&`, то тогава стойност от тип `i32`
        // би трябвало да се присвои на `val`.
        &val => println!("Получих стойност чрез разлагане: {:?}", val),
    }

    // За да се избегне ползването на `&`, трябва да достъпим пряко, преди да сравним.
    match *reference {
        val => println!("Получих стойност чрез дерефериране: {:?}", val),
    }

    // Какво, ако нямаме препратка към данни? Препратка към данните имахме в
    // горния пример (`&4`), защото дясната страна вече беше препратка. Това тук
    // не е препратка, защото дясната част на присвояването (`3`) не е препратка.
    let _not_a_reference = 3;

    // Ръждьо предоставя ключовата дума `ref` точно с тази цел. Присвояването се
    // променя така, че се създава препратка към стойността от дясната страна и
    // тази препратка бива обвързана с променливата.
    let ref _is_a_reference = 3;

    // Съответно, ако опишем две стойности без препратки, можем да получим
    // препратки към тези стойности чрез `ref` и `ref mut`.
    let value = 5;
    let mut mut_value = 6;

    // Използвайте ключовата дума `ref`, за да създадете препратка.
    match value {
        ref r => println!("Получих препратка към стойност: {:?}", r),
    }

    // По подобен начин използвайте `ref mut`.
    match mut_value {
        ref mut m => {
            // Получихме препратка. Трябваше да достъпим стойността пряко,
            // преди да можем да добавим нещо към нея.
            *m += 10;
            println!("Добавихме 10. `mut_value`: {:?}", m);
        },
    }
}
```

## Бел. прев.

[^dereferencing]: достъпвам пряко, дереферирам –  dereference. Пряк достъп (до данните от препратката) –
  dereferencing. Достъпвам пряко (без препратка) – dereference

ЗАДАЧА за преводача!: да се прегледа и ако трябва да се преработи!!!

https://ciksiti.com/bg/chapters/10350-dereference-pointer-in-c--in-ubuntu-20-04

https://learn.fmi.uni-sofia.bg/pluginfile.php/50356/mod_resource/content/0/pointref.pdf

### Вижте също:

[Образецът ref](../../../scope/borrow/ref.md)
