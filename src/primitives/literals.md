# Буквални стойности и оператори

Целите числа могат да бъдат представени и като шестнадесетични, осмични или
двоични, като се използват следните представки: `0x`, `0o` или `0b`.

В числовите буквални стойности могат да се ползват подчертавки за по-добра
четимост, например:
`1_000` е същото като `1000`, а `0.000_001` е `0.000001`.

Ръст поддържа и [експоненциално записване][enote]: `1e6`, `7.6e-4`. Използваният
тип е `f64`.

Трябва да кажем на компилатора типа на буквалната стойност, който желаем да
ползваме за нея. Засега ще ползваме наставката `u32`, за да укажем, че числото
е цяло, 32-битово и без знак. С наставката `i32` ще указваме 32-битово цяло
число със знак.

Операторите и предимството, с което се изпълняват [в Ръст][rust op-prec] са подобни на другите
[подобни на C][op-prec] езици.

```rust,editable
fn main() {
    // Сбор на цели числа
    println!("1 + 2 = {}", 1u32 + 2);

    // Разлика от цели числа
    println!("1 - 2 = {}", 1i32 - 2);
    // ЗАДАЧА ^ Променете `1i32` на `1u32`, за да видите защо е важен типа.

    // Научно записване
    println!("1e4 is {}, -2.5e-3 is {}", 1e4, -2.5e-3);

    // Съкратено логическо записване
    println!("true AND false is {}", true && false);
    println!("true OR false is {}", true || false);
    println!("NOT true is {}", !true);

    // Побитови действия
    println!("0011 AND 0101 is {:04b}", 0b0011u32 & 0b0101);
    println!("0011 OR 0101 is {:04b}", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 << 5 is {}", 1u32 << 5);
    println!("0x80 >> 2 is 0x{:x}", 0x80u32 >> 2);

    // Използвайте подчертавки за по-добра четимост!
    println!("One million is written as {}", 1_000_000u32);
}
```

[enote]:https://bg.wikipedia.org/wiki/Експоненциален_запис
[rust op-prec]: https://doc.rust-lang.org/reference/expressions.html#expression-precedence
[op-prec]: https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages
