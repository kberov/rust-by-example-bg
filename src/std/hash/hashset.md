# HashSet

Можем да гледаме на `HashSet` (_безредно множество_[^set]) като на безредица (`HashMap`), в
която ни занимават само ключовете (`HashSet<T>` е всъщност просто обвивка около
`HashMap<T, ()>`).

„Какъв е смисълът?“, ще попитате. „Мога просто да запиша ключовете във `Vec`.“

Неповторима способност на `HashSet` е, че обезпечава _неповторимост_[^unique] на членовете
си. Това е договорът, който всяко неподредено множество спазва. `HashSet` е просто
само едно от въплъщенията. (Вижте също: [`BTreeSet`][treeset])

Ако въведем вече същесвуваща в множеството стойност (нововъведената стойност е равна
на някоя съществуваща вече в множеството и хешовете им са еднакви), то новата
стойност ще замести старата.

Това е велико, ако не искате повтарящи се стойности или ако искате да знаете
дали дадена стойност вече я има.

Но множествата могат и повече.

Те имат четири главни действия (всяко от тях връща повторител):

* `union`: (обединение) взема всички неповторими членове _и от двете_ множества;

* `difference`: (разлика) взема всички членове от първото множество, които _не са във второто_;

* `intersection`: (пресичане) взема само тези членове, които са _и в двете_ множества;

* `symmetric_difference`: (съразмерна разлика) взема всички членове, които са _или в едното, или в другото множество, но не и в двете_.

Да пробваме всичките действия в следващия пример:

```rust,editable,ignore,mdbook-runnable
use std::collections::HashSet;

fn main() {
    let mut a: HashSet<i32> = vec![1i32, 2, 3].into_iter().collect();
    let mut b: HashSet<i32> = vec![2i32, 3, 4].into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&4));

    // `HashSet::insert()` връща false, ако въвежданата стойност вече присъства.
    assert!(b.insert(4), "Стойността 4 вече присъства в множество B!");
    // ПОПРАВКА ^ Коментирайте този ред.

    b.insert(5);

    // Ako типът на членовете на дадена сбирка осъществява `Debug`, то и самата
    // сбирка осъществява `Debug`.
    // Обикновено отпечатва членовете си във вида `[elem1, elem2, ...]`
    println!("A: {:?}", a);
    println!("B: {:?}", b);

    // Отпечатваме [1, 2, 3, 4, 5] в произволен ред.
    println!("Обединение: {:?}", a.union(&b).collect::<Vec<&i32>>());

    // Това би трябвало да отпечати [1]
    println!("Разлика: {:?}", a.difference(&b).collect::<Vec<&i32>>());

    // Отпечатва [2, 3, 4] в произволен ред.
    println!("Intersection: {:?}", a.intersection(&b).collect::<Vec<&i32>>());

    // Опечатва [1, 5]
    println!("Съразмерна разлика: {:?}",
             a.symmetric_difference(&b).collect::<Vec<&i32>>());
}
```

(Примерите са приспособени от [документацията][hash-set].)

## Б. пр.

[^set]: безредно множество (мат.) – set 

[^unique]: неповторимост – uniqueness; неповторим – unique

[treeset]: https://doc.rust-lang.org/std/collections/struct.BTreeSet.html
[hash-set]: https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference
